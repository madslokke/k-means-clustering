<html lang="da">
<head>

  <title>K-means clustering</title>
  <style>
      canvas {
          display: block;
          margin: 10px auto;
          border: 1px solid black;
      }
  </style>
</head>
<body>

<div style="display: flex; justify-content: space-evenly;">
  <div style="display: flex; flex-direction: column">
    <label for="data">Data fx 1;1</label>
    <textarea cols="10" rows="20" id="data">
1;2
2;1
2;4
1;3
2;2
3;1
1;1
7;3
8;2
6;4
7;4
8;1
9;2
10;8
9;10
7;8
7;9
8;11
9;9
    </textarea>
    <div>
      <label for="means">Grupper</label>
      <input id="means" value="3"/>
    </div>
    <button onclick="setup()">
      Genererer k-means clustering
    </button>
  </div>
  <div>
    <canvas id="canvas" height="400" width="400"></canvas>
    <p>Score: <span id="score"></span></p>
  </div>
</div>

<script>
  var canvas;
  var ctx;
  var height = 400;
  var width = 400;
  var data = [];
  var means = [];
  var assignments = [];
  var dataExtremes;
  var dataRange;
  var drawDelay = 2000;
  var score = 0;

  function setup() {

    console.log(data);
    console.log(means);
    console.log(assignments);
    dataRange = null;
    dataExtremes = null;
    means = [];
    data = [];
    assignments = [];
    score = 0;

    canvas = document.getElementById('canvas');
    ctx = canvas.getContext('2d');

    data = convertTextToData();
    dataExtremes = getDataExtremes();
    dataRange = getDataRanges(dataExtremes);
    means = initMeans(document.getElementById('means').value);

    makeAssignments();
    draw();

    setTimeout(run, drawDelay);
  }

  function convertTextToData() {
    var value = document.getElementById('data').value;
    value = value.split("\n").filter(d => d.includes(';')).map(d => d.split(";").map(d => +d));
    return value;
  }

  function getDataRanges(extremes) {
    var ranges = [];

    for (var dimension in extremes) {
      ranges[dimension] = extremes[dimension].max - extremes[dimension].min;
    }

    return ranges;

  }

  function getDataExtremes() {

    var extremes = [];

    for (var i in data) {
      var point = data[i];

      for (var dimension in point) {
        if (!extremes[dimension]) {
          extremes[dimension] = {min: 1000, max: 0};
        }

        if (point[dimension] < extremes[dimension].min) {
          extremes[dimension].min = point[dimension];
        }

        if (point[dimension] > extremes[dimension].max) {
          extremes[dimension].max = point[dimension];
        }
      }
    }

    return extremes;

  }

  function initMeans(k) {

    if (!k) {
      k = 3;
    }

    while (k--) {
      var mean = [];

      for (var dimension in dataExtremes) {
        mean[dimension] = dataExtremes[dimension].min + (Math.random() * dataRange[dimension]);
      }

      means.push(mean);
    }

    return means;

  };

  function makeAssignments() {

    for (var i in data) {
      var point = data[i];
      var distances = [];

      for (var j in means) {
        var mean = means[j];
        var sum = 0;

        for (var dimension in point) {
          var difference = point[dimension] - mean[dimension];
          difference *= difference;
          sum += difference;
        }

        distances[j] = Math.sqrt(sum);
      }

      assignments[i] = distances.indexOf(Math.min.apply(null, distances));
    }

  }

  function moveMeans() {

    makeAssignments();

    var sums = Array(means.length);
    var counts = Array(means.length);
    var moved = false;

    for (var j in means) {
      counts[j] = 0;
      sums[j] = Array(means[j].length);
      for (var dimension in means[j]) {
        sums[j][dimension] = 0;
      }
    }

    for (var point_index in assignments) {
      var mean_index = assignments[point_index];
      var point = data[point_index];
      var mean = means[mean_index];

      counts[mean_index]++;

      for (var dimension in mean) {
        sums[mean_index][dimension] += point[dimension];
      }
    }

    for (var mean_index in sums) {
      if (0 === counts[mean_index]) {
        sums[mean_index] = means[mean_index];

        for (var dimension in dataExtremes) {
          sums[mean_index][dimension] = dataExtremes[dimension].min + (Math.random() * dataRange[dimension]);
        }
        continue;
      }

      for (var dimension in sums[mean_index]) {
        sums[mean_index][dimension] /= counts[mean_index];
      }
    }

    if (means.toString() !== sums.toString()) {
      moved = true;
    }

    means = sums;

    return moved;

  }

  function run() {

    var moved = moveMeans();
    draw();

    if (moved) {
      setTimeout(run, drawDelay);
    }

  }

  function draw() {

    score = 0;
    ctx.clearRect(0, 0, width, height);

    ctx.globalAlpha = 0.3;

    // Draw grid
    for (var x = dataExtremes[0].min; x < width; x += (width / (dataRange[0] + 2))) {
      ctx.moveTo(x, 0);
      ctx.lineTo(x, 400);
      ctx.strokeStyle = "#ddd";
      ctx.stroke();
    }

    for (var y = dataExtremes[1].min; y < height; y += (height / (dataRange[1] + 2))) {
      ctx.moveTo(0, y);
      ctx.lineTo(400, y);
      ctx.strokeStyle = "#ddd";
      ctx.stroke();
    }
    ctx.textBaseline = "top";
    ctx.textAlign = "left";
    ctx.fillText("( 0 , 0 )", 8, 5);
    ctx.textAlign = "right";
    ctx.textBaseline = "bottom";

    ctx.fillRect(0, 0, 3, 3);
    ctx.fillRect(397, 397, 3, 3);


    ctx.fillText("( " + (dataRange[0] + 2) + " , " + (dataRange[1] + 2) + " )", 392, 390);

    // Draw lines
    for (var point_index in assignments) {
      var mean_index = assignments[point_index];
      var point = data[point_index];
      var mean = means[mean_index];

      score +=  Math.sqrt(Math.abs(Math.pow(point[0]-mean[0], 2) + Math.pow(point[1]-mean[1], 2)));

      ctx.save();

      ctx.strokeStyle = 'blue';
      ctx.beginPath();
      ctx.moveTo(
        (point[0] - dataExtremes[0].min + 1) * (width / (dataRange[0] + 2)),
        (point[1] - dataExtremes[1].min + 1) * (height / (dataRange[1] + 2))
      );
      ctx.lineTo(
        (mean[0] - dataExtremes[0].min + 1) * (width / (dataRange[0] + 2)),
        (mean[1] - dataExtremes[1].min + 1) * (height / (dataRange[1] + 2))
      );
      ctx.stroke();
      ctx.closePath();

      ctx.restore();
    }
    ctx.globalAlpha = 1;

    // Draw dots
    for (var i in data) {
      ctx.save();

      var point = data[i];

      var x = (point[0] - dataExtremes[0].min + 1) * (width / (dataRange[0] + 2));
      var y = (point[1] - dataExtremes[1].min + 1) * (height / (dataRange[1] + 2));

      ctx.strokeStyle = '#333333';
      ctx.translate(x, y);
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2, true);
      ctx.stroke();
      ctx.closePath();

      ctx.restore();
    }

    // Draw center of means
    for (var i in means) {
      ctx.save();

      var point = means[i];

      var x = (point[0] - dataExtremes[0].min + 1) * (width / (dataRange[0] + 2));
      var y = (point[1] - dataExtremes[1].min + 1) * (height / (dataRange[1] + 2));

      ctx.fillStyle = 'green';
      ctx.translate(x, y);
      ctx.beginPath();
      ctx.arc(0, 0, 5, 0, Math.PI * 2, true);
      ctx.fill();
      ctx.closePath();

      ctx.restore();

    }

    document.getElementById("score").innerText = score;

  }
</script>

</body>
</html>